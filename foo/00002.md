---
title: 백엔드 개발을 위한 핸즈온 장고 책 리뷰
tags: ["django", "orm", "queryset]
categories: ["django", "orm"]
---

## 백엔드 개발을 위한 핸즈온 장고

### 3장. ORM과 쿼리셋

- `django.db.Model`을 상속받으면 `id=models.AutoField(primary_key=True,)`를 기본적으로 선언된다.
- 장고 ORM에는 쿼리셋과 매니저 모듈이 존재한다.
  - 쿼리셋: 장고 ORM에서 DB 쿼리의 결과 집합을 다루는 객체
    - 지연 로딩(lazy evaluation) 방식으로 동작 -> 실제 DB에 쿼리를 날리기 전까지는 실행되지 않음
      - 
      ```python
      # 아래의 코드를 작성하더라도 실제 쿼리가 실행되지도 않고, 조회 결과값이 담겨있지도 않음 (lazy이기 때문)
      user_queryset = User.objects.all()

      # QuerySet 자체를 파이썬 list로 변경
      # -> 이 말은 '실제 데이터에 접근하는 시점'에 쿼리가 실행된다고 볼 수 있음
      users = list(user_queryset)

      # get()은 쿼리를 바로 날림
      User.objects.get(username="abc"
      ```
    - filter(), exclude(), order_by() 같은 체이닝 메서드를 통해 점진적으로 조건을 쌓고, 최종적으로 평가될 때 SQL이 실행됨
    - 즉, SQL Builder와 ResultSet을 나타내는 객체임
    - 장고 ORM의 쿼리셋은 JPA 영속성 컨텍스트와 기본적인 매커니즘과 거의 비슷한듯?
      - 다른 점으로 캐싱된 데이터에 대한 생명 주기, 더티채킹없음이 있는듯
    - 단일 조회 권장 방법
      ```python
      try:
          user = User.objects.get(username="abc")
      expect:
          print("존재하지 않는 사용자입니다.")
          raise e
      return user
      ```
    - 장고 ORM 조건 표현식
      - [django conditional-expressions](https://docs.djangoproject.com/en/5.2/ref/models/expressions/#conditional-expressions)
    - 쿼리셋이 즉시 실행되는 연산
      - list(QuerySet)
      - len(QuerySet)
      - QuerySet.first()
      - QuerySet.get()
      - QuerySet[i]
    - 지연 로딩과 즉시 로딩
      - 쿼리셋은 지연 로딩을 기본으로 함
        - 따라서, N+1을 항상 신경써야 함
      - 즉시 로딩은 `select_related()`, `prefetch_related()`를 사용해서 한 번에 쿼리 가능
        ```python
        memu_querysey = (Menu.objects.select_related("restaurant", "grocery_store").filter(name__contains="파스타")

        # SQL
        SELECT ...
        FROM menu m
        INNER JOIN restaurant r ON m.rastaurant_id = r.id
        INNER JOIN grocery_store gs ON m.grocery_store_id = gs.id
        WHERE menu.name LIKE '%파스타%'
        ```
      - JPA에서도 가지던 고민
        - 1) 연관관계를 맺고 `fetch join`처럼 객체 그래프를 그냥 탐색할 수 있도록 조인을 거는 것
          - 여기서도 객체 그래프를 어디서 끊을까에 대한 고민이 필요
            - 1-1) 예를 들어, 애그리거트 단위로 끊는다던지 -> 팀내에 도메인 모델 중심의 디자인에 대한 싱크가 맞아야 할 듯
            - 1-2) 아니면 필요에 따라 다 연결을 한다..? -> 비효율적일듯
        - 2) 연관관계를 끊고 `id(key)` 기반으로 각각을 따로 조회하는 것
          - 다만, 이렇게 조회를 했을때 들었던 생각은 이러면 ORM을 잘 활용하지 못하는건 아닐까(정확히는 ORM 연관관계)하는 생각이 있음
          - 따라서 지금 내 기준으로 베스트를 고른다면 `1-1: 연관관계를 맺되, 애그리거트 단위로 끊는다`가 적절할듯
    - 장고 ORM도 JPA와 마찬가지로 단방향, 양방향 관계를 맺을 수 있음.
      - 단, '다(Many)'에 해당쪽에 `to 옵션`을 지정해야 함. 양방향 관계에서 일(One)에는 `to 옵션`이 붙지 않음
      - 마찬가지로 연관관계를 다루는것에 용이한 구조를 띄는게 좋으니 단방향 관계를 최대한 지향하면서도 애그리거트안에서 양방향은 가능하도록 하는게 좋을듯함
        - 근데, OneToMany로 양방향 맺는건 비교적 더 까다로운듯,,

---

### 필요한 상황이 오면 알아볼 키워드

- 모델.objects.annotate()
- 모델.objects.aggregate()
  - "간단한 통계 쿼리는 괜찮지만 통계 쿼리가 복잡해진다면 SQL을 작성하라."라는 책 내용으로 보면 JPQL로 통계 쿼리짠다는 느낌이라 상황, 기준에 맞추어 적용하면 될 듯
  - 하드한 통계 쿼리라면 p130, p206과 같이 raw query(예를 들면, with절..?)를 만들어서 Unmanaged Model로 관리하는 것도 방법

### 별도 정리가 필요한 주제
- GIL
- 파이썬 컬렉션 프레임워크
- 파이썬에서 None 값에 대한 처리 -> python에서의 Optional은?
- 예외 처리 try, expect
- N+1 쿼리 문제에 대한 발생 케이스도 만들어서 테스트 해보자
