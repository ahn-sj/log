---
title: 쿠버네티스 기본 명령어와 파드, ReplicaSet, Deployment
tags: ["kubernetes", "kubectl", "pod", "replicaset", "deployment", "workload"]
categories: ["kubernetes"]
---


## kubectl 기본 명령어

**기본 구조**

```
$ kubectl [동작] [리소스] [이름] [옵션]
ex) kubectl get pod mypod -o yaml
```

**자주 쓰이는 동작 명령어**

|동작|의미|
|---|---|
|get|리소스 조회|
|describe|상세 정보 확인|
|apply|리소스 생성/변경 (yaml 기반)|
|delete|리소스 삭제|
|logs|로그 확인|
|exec|컨테이너 안으로 접속|

### 파드 생성

1. yaml에 정의한 리소스 스펙을 정의
2. `kubectl apply -f {}.yaml`

```bash
$ kubectl get pods
--------------------------
NAME    READY   STATUS              RESTARTS   AGE
mypod   0/1     ContainerCreating   0          8s
```

```bash
$ kubectl get pods -o wide
--------------------------
NAME    READY   STATUS    RESTARTS   AGE     IP         NODE             NOMINATED NODE   READINESS GATES
mypod   1/1     Running   0          2m14s   10.1.0.6   docker-desktop   <none>           <none>
```

### 파드 접속

```bash
$ kubectl exec -it mypod -- /bin/bash
--------------------------
root@mypod:/#
```

## Multi-container Pod

- 파드는 여러개의 컨테이너를 연결된 상태로 실행할 수 있는데, 이런 구조를 멀티 컨테이너 파드 또는 사이드카 패턴이라고 부름
- 이때, 이 컨테이너는 동일한 네트워크를 공유하게 됨


## ReplicaSet과 Deployment

### 왜 단독 파드만으로는 운영이 어려울까

- 파드는 쿠버네티스에서 가장 작은 실행 단위이지만 운영 환경에서는 하나의 파드만으로 운영하기에는 충분하지 않음
- 그 이유는,
  - 파드는 일회성으로 중단되면 자동 복구되지 않음
  - 파드를 수동으로 여러 개 만들어도 서로간의 상태 동기화가 안 됨
  - 버전 업데이트나 롤백이 불가능함. 즉, 수평 확장이 어렵다

다시 말해, 파드는 컨테이너 실행 단위일뿐 운영 단위는 아님

### Workload

- 파드의 단독 운영의 한계에 대한 문제를 해결하기 위해 등장한 것이 Workload 리소스임.
- 워크로드는 쿠버네티스 클러스터에서 실행되는 하나 이상의 파드들에 대해 자동으로 생성, 관리, 복구, 확장하는 리소스임
- 대표적인 Workload 리소스
  - ReplicaSet: 지정한 수의 Pod가 항상 실행되도록 유지
  - Deployment: 무중단 배포, 롤백 등을 지원하며 ReplicaSet을 관리함
  - StatefulSet: 각 파드에 고유한 ID와 스토리지를 부여해 상태를 보존함
  - DaemonSet: 모든 노드에 하나씩 파드를 배포하는데 사용됨
  - Job: 작업이 완료될때까지 단발성으로 실행되는 일회성 작업 리소스
  - CronJob: 정해진 스케줄러에 따라 Job을 주기적으로 실행함

### ReplicaSet

- ReplicaSet은 항상 정해진 개수의 동일한 파드를 유지해주는 리소스로 사용자가 원하는 replica 수를 정의하면 쿠버네티스가 알아서 파드를 생성/삭제하여 맞추는 역할을 함
- ReplicaSet은 파드의 상위 관리자 역할을 하는데, 사용자가 ReplicaSet을 만들면 그 안에 정의된 설정에 따라 파드가 관리됨
- 라벨을 기준으로 어떤 파드를 관리할지 결정함
- 새로 생성되는 파드에도 동일한 라벨이 있어야 ReplicaSet이 인식하고 관리할 수 있음

여기서 말하는 라벨은 쿠버네티스 리소스에 붙이는 이름표로, 사람에게 보이는 네임택이 아닌 쿠버네티스가 리소스를 찾는 기준으로 사용됨

즉, ReplicaSet은 이 라벨을 이용해 어떤 파드를 관리해야 하는지 판단하고, 라벨이 올바르지 않으면 ReplicaSet은 그 Pod를 모르는 것으로 간주함

#### ReplicaSet의 구성 요소

|항목|설명|
|---|---|
|replicas|유지할 파드의 수|
|selector|어떤 파드를 관리할 것인지 지정하는 라벨 셀렉터|
|template|파드 템플릿. 새로 정의될 파드의 정의|

```yaml
apiVersion: apps/v1
kind:ReplicaSet
...
spec:
  replicas: 3 # 유지할 파드의 수
  selector:
    matchLabels:
      app: guestbook # 관리할 파드의 라벨
  template: # 새로운 파드를 정의
    metadata:
      labels:
        apps: guestbook # 파드에 붙는 라벨
```

- 여기서 중요한 점은, **selector와 template.metadata.labels 값이 반드시 일치해야 한다는 것**임
- 그렇지 않으면, ReplicaSet이 새 파드를 인식, 관리하지 못하게 됨

#### Pod와 ReplicaSet의 연결 관계

ReplicaSet이 만든 파드에는 metadata.ownerReferences 정보가 자동으로 들어가는데, 이 정보는 '이 파드는 누구에 의해 생성되었는가'를 나타냄

```yaml
kubectl get pods -o yaml
```

<img width="412" height="237" alt="스크린샷 2025-09-15 오후 10 25 41" src="https://github.com/user-attachments/assets/d9a1681a-fe43-40fe-97bd-331adc9ade84" />

### 라벨

- 라벨은 단순한 이름표가 아닌 리소스 제어 범위를 결정짓는 핵심 도구임
- ReplicaSet이 관리할 파드를 정확히 구분하려면 라벨 설계를 신중히 해야함
- 실수로 겹치는 라벨을 주면 의도하지 않은 파드가 삭제되거나 ReplicaSet에 의해 통제될 수 있음
  - 사용자가 직접 생성한 파드에 ReplicaSet이 관리하는 라벨을 붙일 경우 ReplicaSet이 소유권을 가져가서 관리하게 됨

### 주의할 점

- 파드의 template과 selector의 라벨이 정확히 일치하지 않으면 API에서 거부됨
- ReplicaSet은 롤링 업데이트 기능이 없음
- ReplicaSet을 삭제하면 관련 파드도 자동 삭제됨
- 실제 운영 환경에서는 Deployment를 사용하면 ReplicaSet 생성, 관리가 자동화되기 때문에 Deployment 내부에서 자동 생성되는 존재로 이해하는게 더 좋음

### Deployment

- Deployment는 상태를 유지하지 않는 애플리케이션을 실행하기 위해 여러 파드를 생성하기 위한 컨트롤러
- 역할
  - 여러 파드를 자동으로 생성, 유지
  - 롤링 업데이트, 롤백, 버전 관리 지원
  - 선언형 방식으로 동작
  - 사용자가 정의한 원하는 상태를 기준으로 현재 클러스터를 조정
- 구성 요소
  - 하나의 매니페스트 파일로 여러 파드를 안정적으로 운영할 수 있도록 설정
- 매니페스트 설정 정보
  - replicas: 몇 개의 파드를 유지할지
  - selector: 어떤 라벨을 가진 파드를 관리할지
  - template: 어떤 이미지와 설정으로 파드를 만들지
  - strategy: 어떤 방식으로 업데이트를 진행할지 (배포 전략, 기본: RollingUpdate)
  - revisionHistoryLimit: 이전 버전을 얼마나 보관할지

| 항목 | ReplicaSet | Deployment |
|---|---|---|
|기본 역할|지정한 개수의 파드를 유지|파드 유지 + 배포, 롤백 관리
|생성 방식|사용자가 ReplicaSet을 직접 작성 및 생성|사용자가 Deplyment를 작성하면 내부적으로 ReplicaSet을 자동 생성|
|배포 방식|단순 생성/삭제|무중단 롤링 업데이트|
|버전 관리|없음|Revision 기록 및 롤백 기능|

### 컨테이너 이미지 버전 변경 시 동작 예시

- 새로운 ReplicaSet 생성
- 기존 ReplicaSet의 파드 개수를 점진적으로 줄임 (scale down)
- 새로운 ReplicaSet의 파드 개수를 점진적으로 늘림 (scale up) -> 무중단 배포
- 즉, 사용자가 접속한 상태에서 오래된 서버를 하나씩 빼고 새 서버를 순차적으로 추가하는 과정임

### Deployment 의 주요 기능 및 특징

- 롤링 업데이트: 새 버전의 애플리케이션을 점진적으로 배포하여 서비스 중단을 방지
- 롤백: 문제가 발생하면 이전 상태로 빠르게 복구
- 자동 ReplicaSet 관리: 새로운 파드 템플릿 적용 시 기존 ReplicaSet을 자동으로 교체
- 확장성 조절: 수요에 따라 레플리카 수를 늘리거나 줄일 수 있음
- 상태 확인: 현재 배포 상태와 진행 상황을 실시간 점검이 가능함


---

## 관련 키워드

- 사설 IP와 CIDR
  - `kubectl get pods -o wide`의 실행 껼과로 파드의 IP가 사설 IP인걸 보면 결국 게이트웨이 역할을 하는 곳은 별도로 존재하고, 내부 파드들의 리소스 관리를 하는 형태로 동작할 것 같음
    - 따라서, 이걸 잘 이해하려면 IP 대역에 대한 이해와 인터넷망과 사설IP와의 통신을 하는것에 대한 배경이 있어야 이해하는데 용이할듯?

